#include "queue_bmm.h"

import core.thread;
import std.traits;
import std.stdio;
import std.datetime;
//alias StopWatch = std.datetime.stopwatch.StopWatch;
import std.concurrency : receiveOnly, send, spawn, Tid, thisTid;

alias voidpp = void**;
extern(C) alias element_cleanup_callback = void function(lfds711_queue_bmm_state*, void*, void*);
voidpp NULL_PTR = null;
element_cleanup_callback NULL_CB = null;

unittest {
    import std.traits;

    class C;
    union U;
    struct S;
    interface I;
    
    static assert( isAggregateType!C);
    static assert( isAggregateType!U);
    static assert( isAggregateType!S);
    static assert( isAggregateType!I);
    static assert(!isAggregateType!void);
    static assert(isArray!string);
    static assert(isArray!(int[]));
    static assert(!isAggregateType!(C[string]));
    static assert(!isAggregateType!(void delegate(int)));
}


bool treatAsStructInC(T)() {
  // https://dlang.org/library/std/traits/is_aggregate_type.html
  // string, array is not isAggregateType
  static if (is(T == struct) || is(T == union) || isArray!T) {
    return true;
  } else {
    // basic type int|double, class, interface
    return false;
  }
}

// this class is shared: otherwise, please use a normal queue
shared class queue_bmm(T) {  // do NOT use shared, let the user decide
 public:

  static if (treatAsStructInC!T) {
    alias PushT = ref T;
    alias  PopT = T*;
    immutable PopT invalidPop = null;
  } else {
    alias PushT = T;
    alias  PopT = T;
    static if (is(T == class) || is(T == interface)) {  // these are pointers in C
      immutable PopT invalidPop = null;
    } else {
      immutable PopT invalidPop = T.max;  // 0 is typically used by user!
    }
  }

  this(size_t n=1024) {
    _queue = cast(shared)(queue_bmm_new(n));  // pointer from C is always global can be accessed by any threads
    capacity = n;
  }

  // return false, when the queue is full
  // T: could be stuct|class, string|array, int|double
  bool push(ref T value) {
   static if(treatAsStructInC!T) {
    void* v = cast(void*)(&value);
   } else {
    void* v = cast(void*)value;
   }
    return queue_bmm_push(cast(c_queue_bmm*)_queue, v);
  }

  // return invalidPop if queue empty
  // https://www.liblfds.org/mediawiki/index.php?title=r7.1.1:Function_lfds711_queue_bmm_dequeue#Return_Value
  // Returns 1 on a successful dequeue. Returns 0 if dequeing failed. Dequeuing only fails if the queue is empty.
  PopT pop() {
    int ok;
    void* value = queue_bmm_pop(cast(c_queue_bmm*)_queue, &ok);
    if (ok) {
      return cast(PopT)value;
    }
    return cast(PopT)invalidPop;
  }

  bool isInvalid(ref PopT p) {
    return p == cast(PopT)invalidPop;
  }

  size_t length() {
    return queue_bmm_length(cast(c_queue_bmm*)_queue);
  }

  bool full() {
    return this.length() == capacity;
  }

  /* this bool is not guaranteed to be correct!
     https://www.liblfds.org/mediawiki/index.php?title=r7.1.1:Function_lfds711_queue_bmm_query#Notes
  */
  bool empty() {
    return 0 == this.length();
  }

  ~this() {
    queue_bmm_destroy(cast(c_queue_bmm*)_queue);
  }

 private:
  c_queue_bmm* _queue;
  size_t capacity;
  // PopT invalidPop;  // signal invalid element, e.g. pop from empty queue
}


//unittest {

const size_t n = 100_000_000;
alias SafeQueue = queue_bmm;

void threadProducer(shared(SafeQueue!int) queue) {
  foreach (int i; 0..n) {
    for (;;) {
      if (queue.push(i)) {break;}
      Thread.yield();
    }
  }
}

void threadConsumer(shared(SafeQueue!int) queue) {
  StopWatch sw;
  sw.start();  
  long sum = 0;
  int p;

  foreach (i; 0..n) {
    for (;;) {
      p = queue.pop();
      // if (queue.isInvalid(p)) {  // empty may not be accurate, sync call on shared object is very expensive
      if (p != queue.invalidPop) {
        break;
      }
      Thread.yield();
    }
    sum += p;
  }

  sw.stop();
  writefln("received %d messages in %d msec sum=%d speed=%d msg/msec", n, sw.peek().msecs, sum, n/sw.peek().msecs);
  assert(sum == (n*(n-1)/2));
}

// will push pop 100_000_000 int
void testIntQueue() {
  auto queue = new shared(SafeQueue!int);

  writeln(int.init, int.max, queue.invalidPop);
  spawn(&threadProducer, queue);
  spawn(&threadConsumer, queue);
}

void testStringQueue() {
  string name = "string: Madge The Skutter";
  string* temp_td;

  auto queue = new shared(queue_bmm!string)(2);
  assert(0 == queue.length());
  assert(queue.empty());
  assert(!queue.full());

  assert(name == "string: Madge The Skutter");
  queue.push(name);
  assert(1 == queue.length());

  string full = "full";
  queue.push(full);  // won't store string literal
  assert(2 == queue.length());
  assert(queue.full());

  name ~= "; change the pushed after push & before pop";
  temp_td = queue.pop();
  assert(1 == queue.length());

  writeln(name);
  writeln(*temp_td);
  assert(name     == "string: Madge The Skutter; change the pushed after push & before pop");
  assert(*temp_td == "string: Madge The Skutter; change the pushed after push & before pop");

  temp_td = queue.pop();
  writeln(*temp_td);
  assert(0 == queue.length());
  assert(*temp_td == "full");
}

void testStructQueue() {
  struct test_data {
    string name;
  }

  test_data  td;
  test_data* temp_td;
  td.name = "struct: Madge The Skutter";

  auto queue = new shared(queue_bmm!test_data);
  assert(td.name == "struct: Madge The Skutter");
  queue.push(td);
  td.name ~= "; after push & before pop";
  temp_td = queue.pop();
  assert(temp_td.name == "struct: Madge The Skutter; after push & before pop");

  printf( "skutter name = %s %d\n", &(temp_td.name[0]), voidpp.sizeof );
}

void testClassQueue() {
  class test_data {
    string name;
  }

  test_data  td = new test_data;
  test_data temp_td;
  td.name = "class: Madge The Skutter";

  auto queue = new shared(queue_bmm!test_data);
  assert(td.name == "class: Madge The Skutter");
  queue.push(td);
  td.name ~= "; after push & before pop";
  temp_td = queue.pop();
  assert(temp_td.name == "class: Madge The Skutter; after push & before pop");

  assert(td is temp_td);
  assert(td == temp_td);

  printf( "skutter name = %s %d\n", &(temp_td.name[0]), voidpp.sizeof );
}

void main() {
  testStringQueue();
  testStructQueue();
  testClassQueue();
  testIntQueue();
}

//main();

//}
